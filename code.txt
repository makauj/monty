#ifndef MAIN_H
#define MAIN_H

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#define EXIT_FAILURE 1
#define STACK 0
#define QUEUE 1
#define DELIMS " \n\t\a\b"


/**
 * struct stack_s - doubly linked list representation of a stack (or queue)
 * @n: integer
 * @prev: points to the previous element of the stack (or queue)
 * @next: points to the next element of the stack (or queue)
 *
 * Description: doubly linked list node structure
 * for stack, queues, LIFO, FIFO
 */
typedef struct stack_s
{
	int n;
	struct stack_s *prev;
	struct stack_s *next;
} stack_t;

/**
 * struct instruction_s - opcode and its function
 * @opcode: the opcode
 * @f: function to handle the opcode
 *
 * Description: opcode and its function
 * for stack, queues, LIFO, FIFO
 */
typedef struct instruction_s
{
	char *opcode;
	void (*f)(stack_t **stack, unsigned int line_number);
} instruction_t;

/* OPCODE functions */
void monty_push(stack_t **stack, unsigned int line_number);
void monty_pall(stack_t **stack, unsigned int line_number);
void monty_pint(stack_t **stack, unsigned int line_number);
void monty_pop(stack_t **stack, unsigned int line_number);
void monty_swap(stack_t **stack, unsigned int line_number);
void monty_add(stack_t **stack, unsigned int line_number);
void monty_nop(stack_t **stack, unsigned int line_number);


/* HELPER FUNCTIONS*/
void handle_error(unsigned int line_num, const char *message);
void free_stack(stack_t *stack);

#endif /* MAIN_H */

#include "main.h"

/**
 * monty_push - function to add a value to a list
 * @stack: A pointer to the top of a stack
 * @line_value: current working position
 */

void monty_push(stack_t **stack, unsigned int line_value)
{
	int val;
	stack_t *new_node = malloc(sizeof(stack_t));
	char *endptr;

	if (*endptr != '\0')
	{
		handle_error(line_value, "usage: push integer");
	}

	if (!new_node)
	{
		fprintf(stderr, "Error: malloc failed\n");
		exit(EXIT_FAILURE);
	}

	new_node->n = val;
	new_node->next = *stack;
	new_node->prev = NULL;
	if (*stack)
	{
		(*stack)->prev = new_node;
	}
	*stack = new_node;
}

/**
 * monty_pall - prints the values of a stack
 * @stack: pointer to the top of a stack
 * @line_number: position of current operation
 *
 * Return: void
 */

void monty_pall(stack_t **stack, unsigned int line_number)
{
	stack_t *head = *stack;

	(void)(line_number);

	while (head)
	{
		printf("%d\n", head->n);
		head = head->next;
	}
}
#include "main.h"

/**
 * monty_pint - function prints value at the top of a stack
 * @stack: pointer to the tp of a stack
 * @line_number: position of current operation
 */
void monty_pint(stack_t **stack, unsigned int line_number)
{
	stack_t *current = *stack;

	(void)(line_number);

	if (!current)
	{
		handle_error(0, "can't pint, stack empty\n");
	}
	printf("%d\n", current->n);
}
#include "main.h"

/**
 * monty_pchar - opcode to print the char at the top of the stack
 * @stack: A pointer to the top of a stack
 * @line_number: current working position
 */

void monty_pchar(stack_t **stack, unsigned int line_number)
{
	stack_t *top_node = *stack;
	int ascii_value;

	if (!top_node)
	{
		handle_error(line_number, "can't pchar, stack empty");
	}

	ascii_value = top_node->n;

	if (ascii_value < 0 || ascii_value > 127)
	{
		handle_error(line_number, "can't pchar, calue out of range");
	}

	printf("%c\n", (char)ascii_value);
}
#include "main.h"

/**
 * monty_pstr - Opcode to print the string contained in a stack
 * @stack: A pointer to the top node in a stack
 * @line_number: The current working line number
 */

void monty_pstr(stack_t **stack, unsigned int line_number)
{
	stack_t *current = *stack;
	char character;
	int av;

	if (!current)
		return;
	while (current)
	{
		av = current->n;
		if (av == 0 || av < 0 || av > 127)
			break;

		character = (char)av;
		print("%c", character);

		current = current->next;
	}
	print("\n")
}
#include "main.h"

/**
 * monty_rotl - function prints value at the top of a stack
 * @stack: pointer to the tp of a stack
 * @line_number: position of current operation
 */

void monty_rotl(stack_t **stack, unsigned int list_number)
{
	stack_t *top_node = *stack;
	stack_t *second_node, *last_node;

	if (!top_node || !top_node->next)
		return;

	second_node = top_node->next;
	top_node->next = NULL;
	second_node->prev = NULL;

	last_node = second_node;

	while (last_node->next);
	{
		last_node = last_node->next;
	}

	last_node->next = top_node;
	top_node->prev = last_node;

	*stack = second_node;
}
#include "main.h"

/**
 * monty_rotr - Opcode that rorates the stack to the bottom
 * @stack: A pointer to the top of a stack
 * @line_number: current working position
 */

void monty_rotr(stack_t **stack, unsigned int line_number)
{
	stack_t *top_node = *stack;
	stack_t *last_node;

	if (!top_node || !top_node->next)
		return;

	while (last_node->next)
	{
		last_node = last_node->next;
	}

	last_node->prev->next = NULL;
	last_node->prev = NULL;
	last_node->next = top_node;
	top_node->prev = last_node;

	*stack = last_node;
}
#include "main.h"

/**
 * monty_pop - function to remove the top element of the stack
 * @stack: pointer to the top of a stack
 * @line_number: position of current operation
 */

void monty_pop(stack_t **stack, unsigned int line_number)
{
	stack_t *current = *stack;

	if (current != NULL)
	{
		handle_error(line_number, "can't pop an empty stack");
	}

	current = current->next;
	if (current)
	{
		current->prev = NULL;
	}
	free(current);
}
#include "main.h"

/**
 * monty_swap - function swaps the two top elements of a stack
 * @stack: pointer to the tp of a stack
 * @line_number: position of current operation
 */

void monty_swap(stack_t **stack, unsigned int line_number)
{
	stack_t *top_node = *stack;
	stack_t *temp;
	stack_t *next_node;

	if (!top_node || !top_node->next)
	{
		handle_error(line_number, "can't swap, stack too short");
	}
	next_node = top_node->next;
	top_node->next = next_node->next;
	next_node->prev = NULL;

	if (top_node->next)
	{
		top_node->next->prev = top_node;
	}
	next_node->next = top_node;
	top_node->prev = next_node;

	*stack = next_node;
}
#include "main.h"

/**
 * monty_add - function adds the top 2 elements in a stack
 * @stack: pointer to the tp of a stack
 * @line_number: position of current operation
 */
void monty_add(stack_t **stack, unsigned int line_number)
{
	stack_t *top_node = *stack;
	stack_t *next_node;

	if (!top_node || !top_node->next)
	{
		handle_error(line_number, "can't add, stack too short");
	}

	next_node = top_node->next;
	next_node->n += top_node->n;

	*stack = next_node;
	next_node->next = top_node->next;

	if (top_node->next)
	{
		top_node->next->prev = next_node;
	}

	free(top_node);
}
#include "main.h"

/**
 * monty_nop - function does nothing
 * @stack: pointer to the tp of a stack
 * @line_number: position of current operation
 */

void monty_nop(stack_t **stack, unsigned int line_number)
{
	(void)stack;
	(void)line_number;
}
#include "main.h"

/**
 * monty-sub - opcaoe to subtract the first 2 elements in a stack
 * @stack: A pointer to the top of a stack
 * @line_value: current working position
 */

void monty_sub(stack_t **stack, unsigned int line_number)
{
	stack_t *top_node = *stack;
	stack_t *next_node;

	if (!top_node || !top_node->next)
		handle_error(line_number, "can't sub, stack too short");

	next_node = top_node->next;
	next_node->n -= top_node->n;

	*stack = next_node;
	next_node->next = top_node->next;

	if (top_node->next)
	{
		top_node->next->prev = next_node;
	}

	free(top_node);
}
#include "main.h"

/**
 * monty_div - opcode to divide first 2 elements in a stack
 * @stack: A pointer to the top of a stack
 * @line_value: current working position
 */

void monty_div(stack_t **stack, unsigned int line_number)
{
	stack_t *top_node = *stack;
	stack_t *next_node;

	if (!top_node || !top_node->next)
		handle_error(line_number, "can't div, stack too short");

	if (top_node->n == 0)
		handle_error(line_number, "division by zero");
	next_node = top_node->next;

	next_node->n /= top_node->n;

	*stack = next_node;
	next_node->next = top_node->next;

	if (top_node->next)
	{
		top_node->next->prev = next_node;
	}

	free(top_node);
}#include "main.h"

/**
 * monty_mul - opcode to multiply the top 2 elements of a stack
 * @stack: A pointer to the top of a stack
 * @line_value: current working position
 */

void monty_mul(stack_t **stack, unsigned int line_number)
{
	stack_t *top_node = *stack;
	stack_t *next_node;

	if (!top_node || !top_node->next)
		handle_error(line_number, "can't mul, stack too short");

	next_node = top_node->next;

	next_node->n *=top_node->n;

	*stack = next_node;
	next_node->next = top_node->next;

	if (top_node->next)
	{
		top_node->next->prev = next_node;
	}

	free(top_node);
}#include "main.h"

/**
 * monty_mod - opcode to multiply the top 2 elements of a stack
 * @stack: A pointer to the top of a stack
 * @line_value: current working position
 */

void monty_mod(stack_t **stack, unsigned int line_number)
{
	stack_t *top_node = *stack;
	stack_t *next_node;

	if (!top_node || !top_node->next)
		handle_error(line_number, "can't mod, stack too short");

	if (top_node->n = 0)
		handle_error(line_number, "division by zero")
	next_node = top_node->next;

	next_node->n %=top_node->n;

	*stack = next_node;
	next_node->next = top_node->next;

	if (top_node->next)
	{
		top_node->next->prev = next_node;
	}

	free(top_node);
}
#include "main.h"

/**
 * main - entry into main
 * @argv: arguments
 * @argc: arguments
 *
 * Return: 0
 */

int main(int argc, char *argv[])
{
    char *command = NULL;
    size_t len = 0;
    int line_number = 1;
    char *token, *endptr;
    long value;

    while (getline(&command, &len, stdin) != -1)
    {
        token = strtok(command, " \n");
        if (token == NULL)
        {
            line_number++;
            continue;
        }

        if (strcmp(token, "push") == 0)
        {
            token = strtok(NULL, " \n");
            if (token == NULL)
            {
                error_exit("usage: push integer", line_number);
            }

            value = strtol(token, &endptr, 10);
            if (*endptr != '\0')
            {
                error_exit("usage: push integer", line_number);
            }

            push((int)value);
        }
        else if (strcmp(token, "pall") == 0)
        {
            pall();
        }
        else
        {
            error_exit("unknown instruction", line_number);
        }

        line_number++;
    }

    free(command);
    free_stack();
    return (0);
}#include "main.h"

/**
 * free_stack - function to free memory
 * @stack: pointer to the top of a stack
 */
void free_stack(stack_t *stack)
{
	stack_t *current = stack;
	stack_t *temp;

	while (current)
	{
		temp = current;
		current = current->next;
		free(temp);
	}
}

/**
 * handle_error - error handling function
 * @line_num: line number being executed
 * @message: message to display
 */
void handle_error(unsigned int line_num, const char *message)
{
	fprintf(stderr, "L%u: %s\n", line_num, message);
	exit(EXIT_FAILURE);
}